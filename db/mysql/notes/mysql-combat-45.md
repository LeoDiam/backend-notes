# MySQL 实战 45 讲

Table of Contents
-----------------

* [1. 一条 SQL 查询语句是如何执行的?](#1-一条-sql-查询语句是如何执行的)
   * [连接器](#连接器)
   * [查询缓存（mysql 8 之后废除, 暂不讨论）](#查询缓存mysql-8-之后废除-暂不讨论)
   * [分析器](#分析器)
   * [优化器](#优化器)
   * [执行器](#执行器)
* [2. 一条 SQL 更新语句是如何执行的?](#2-一条-sql-更新语句是如何执行的)
   * [redo log ( InnoDB 特有日志)](#redo-log--innodb-特有日志)
   * [binlog (归档日志)](#binlog-归档日志)
* [3. 事务隔离: 为什么你改了我还看不见?](#3-事务隔离-为什么你改了我还看不见)
* [4. 深入浅出索引](#4-深入浅出索引)
* [5. 全局锁和表锁: 给表加个字段怎么有那么多阻碍?](#5-全局锁和表锁-给表加个字段怎么有那么多阻碍)
* [6. 怎么减少行锁对性能对影响?](#6-怎么减少行锁对性能对影响)
* [7. 事务到底是隔离的还是不隔离的?](#7-事务到底是隔离的还是不隔离的)
* [8. 普通索引和唯一索引, 应该怎么选择?](#8-普通索引和唯一索引-应该怎么选择)
* [9. MySQL 为什么有时候会选错索引?](#9-mysql-为什么有时候会选错索引)
* [10. 怎么给字符串字段加索引?](#10-怎么给字符串字段加索引)
* [11. 为什么我的 MySQL 会 ”抖“ 一下?](#11-为什么我的-mysql-会-抖-一下)
* [12. 为什么表数据删掉一半, 表文件大小不变?](#12-为什么表数据删掉一半-表文件大小不变)
* [13. count(*) 这么慢, 怎么办?](#13-count-这么慢-怎么办)
* [14. "order by" 如何工作?](#14-order-by-如何工作)
* [15. 如何正确显示随机消息?](#15-如何正确显示随机消息)
* [16. 为什么 SQL 语句逻辑相同, 性能差异却巨大?](#16-为什么-sql-语句逻辑相同-性能差异却巨大)
* [17. 为什么我只查一行的语句, 也执行那么慢?](#17-为什么我只查一行的语句-也执行那么慢)
* [18. 幻读是什么? 有什么问题?](#18-幻读是什么-有什么问题)
* [19. 为什么我只查一行的语句, 锁这么多?](#19-为什么我只查一行的语句-锁这么多)
* [20. 有哪些提高性能的方法?](#20-有哪些提高性能的方法)
* [21. 如何保证数据不丢?](#21-如何保证数据不丢)
* [22. 如何保证主备一致?](#22-如何保证主备一致)
* [23. 如何保证高可用?](#23-如何保证高可用)
* [24. 备库为什么会延迟好几个小时?](#24-备库为什么会延迟好几个小时)
* [25. 主库出问题了, 从库怎么办?](#25-主库出问题了-从库怎么办)
* [26. 读写分离有哪些坑?](#26-读写分离有哪些坑)
* [27. 如何判断一个数据库是不是出问题了?](#27-如何判断一个数据库是不是出问题了)
* [28. 删库除了跑路, 还能怎么办?](#28-删库除了跑路-还能怎么办)
* [29. 为什么还有 kill 不掉的语句?](#29-为什么还有-kill-不掉的语句)
* [30. 我查那么多数据, 会不会把数据库内存打爆？](#30-我查那么多数据-会不会把数据库内存打爆)
* [31. 到底可不可以用 join?](#31-到底可不可以用-join)
* [32. join 语句怎么优化?](#32-join-语句怎么优化)
* [33. 为什么临时表可以重名?](#33-为什么临时表可以重名)
* [34. 什么时候会使用内部临时表?](#34-什么时候会使用内部临时表)
* [35. 还要使用 Memory 引擎吗?](#35-还要使用-memory-引擎吗)
* [36. 自增主键为什么不是连续的?](#36-自增主键为什么不是连续的)
* [37. insert 语句的锁为什么那么多?](#37-insert-语句的锁为什么那么多)
* [38. grant 之后要 flush privileges 吗?](#38-grant-之后要-flush-privileges-吗)
* [39. 怎么最快地复制一张表?](#39-怎么最快地复制一张表)
* [40. 要不要使用分区表?](#40-要不要使用分区表)
* [41. 自增 ID 用完了怎么办?](#41-自增-id-用完了怎么办)
* [参考资料](#参考资料)




## 1. 一条 SQL 查询语句是如何执行的?

大体上，`MySQL` 分为两部分：

- Server 层：涵盖 `MySQL` 大多数核心服务功能
- 存储引擎层：负责数据的存储和提取（插件式）



<div align="center"> <img src="logic.png" width="70%"/> </div><br> 

### 连接器

作用：客户端与 `mysql` 建立连接

```mysql
$ mysql -u root -p
Enter password:
```



### 查询缓存（mysql 8 之后废除, 暂不讨论）



### 分析器

作用：`mysql` 需要知道你做什么

分析器是如何工作的？假设我们输入了一条语句：

```mysql
mysql> select * from T where ID=10；
```

1. 词法分析

   将关键字识别出来，例如 `select`, `T` 和 `ID`

2. 语法分析 

   判断语句是否符合 `mysql` 语法

### 优化器

作用：`mysql` 需要知道如何做

优化器是如何工作的？假设我们输入了一条语句：

```mysql
mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

既可以从 `t1` 表取出 `c` = 10 的记录的 `ID` 值，再关联到 `t2` 表，再判断 `t2` 里 `d` 的值是否等于 20，也可以反过来

这两种方法的逻辑结果是相同的，但执行效率不同，优化器就是决定选择哪种方案的



### 执行器

`mysql` 知道了语句的意思，也知道该如何做了，接下来就剩下执行语句了



开始执行之前，先要判断操作者对该表是否有执行查询 / 更新的权限

若有权限（没有权限则直接打回），就打开表直接执行，根据该引擎插件选择其提供的接口



举个例子：

```mysql
mysql> select * from T where ID=10；
```



1. 调用 `InnoDB` 引擎接口取这个表的第一行，判断 `ID` 值是否为 10，若不是则跳过，若有则存在结果集中
2. 遍历
3. 将结果集返回给客户端



## 2. 一条 SQL 更新语句是如何执行的?

了解了查询的基本流程，再看看更新语句

举个例子，创建表 `T`

```mysql
mysql> create table T(ID int primary key, c int);
```

更新数据：

```mysql
mysql> update T set c=c+1 where ID=2;
```

流程跟查询有类似，经过连接器，分析器，执行器

但与查询流程不一样的是，更新流程还涉及到两个重要的日志模块：

- redo log（重做日志）
- binlog（归档日志）



下面先看一个例子：

<div align="center"> <img src="image-20201015200534724.png" width="80%"/> </div><br> 


### redo log ( InnoDB 特有日志)

具体来说，当有一条记录需要更新的时候，`InnoDB` 就会先把记录写到 `redo log`（粉板），并更新内存（保证数据实时性），这个时候更新就算完成。在适当的时候，`InnoDB` 将这个操作更新到磁盘中（打烊后掌柜将粉板的记录更新到汇总账单）



<div align="center"> <img src="redo.png" width="60%"/> </div><br> 

值得注意的是：

- `InnoDB` 的 `redo log` 是固定大小的，这块粉板总共可以记录 4GB 的操作（在清楚当前日志前会确保记录写入磁盘中，持久化）
- 有了 `redo log`，`InnoDB` 可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，称为 `crash-safe`（记录在粉板中）



### binlog (归档日志)

**binlog 是什么? 为什么需要有两份日志?**

`binlog` 是属于 `server` 层的日志，用作归档（没有 `crash-safe` 能力）

这两种日志有以下 3 点区别：

1. `redo log` 是 `InnoDB` 引擎特有的，而 `binlog` 是 `server` 层实现的，所有引擎都可以使用
2. `redo log` 是物理日志，`binlog` 是逻辑日志
3. `redo log` 是循环写的，空间固定会用完，而 `bin log` 是可以追加写入的



举个例子来说明两种日志的区别：

```mysql
mysql> update T set c=c+1 where ID=2;
```

1. 执行器找引擎取 `ID` = 2的这一行，若这一行的数据本来就在内存中，直接返回；否则从磁盘中读入内存，再返回
2. 执行器获取数据后，将 `c` 这一列赋予新值，然后调用引擎接口写入数据
3. 引擎将这行数据更新到内存中，同时将这个更新操作记录写到 `redo log` 中，此时 `redo log` 处于 `prepare` 状态。然后告知执行器执行完成了，随时可以提交事务
4. 执行器生成这个操作的 `binlog`，并把 `binlog` 写入磁盘
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 `redo log` 改成 `commit` 状态，更新完成

<div align="center"> <img src="image-20201025175044474.png" width="50%"/> </div><br> 









## 3. 事务隔离: 为什么你改了我还看不见?

**什么是事务?**

**事务就是要保证一组数据库操作要么全部成功，要么全部失败** 



举个例子，假如 Jack 要给 Rose 转账 1 个亿。这个动作包含了两个关键操作：

1. Jack 账户将减少 1 个亿
2. Rose 账户将增加 1 个亿



万一这两个操作之间突然出现错误比如银行系统崩溃，导致 Jack 账户余额减少而 Rose 账户余额没有增加， 1 个亿离奇消失！

在现实生活中这种情况是不允许发生的



**什么是事务的四大特性?**

事务有四大特性：`ACID`（面试常客）

**A:** Atomicity，确保动作要不全部成功，要不全部失败

**C:** Consistency，执行事务前后，数据保持一致（无论事务成功与否，转账人和收款人金额总额不变）

**I:** Isolation，并发访问数据库时，一个用户的事务不被其他事物所干扰

**D:** Durability，一个事务被 `commit` 之后，数据库中的数据改变是持久的



**并发事务会带来什么问题?**

1. 脏读 `dirty read`：

   当事务 `t1` 正在访问数据并且对数据进行了修改，但仍未提交到数据库中，事务 `t2` 访问了并使用了这个数据，则称这个数据为 "脏数据"

2. 丢失修改 `lost to modify`

   当事务 `t1` 读取一个数据时，事务 `t2` 也访问了该数据，且在事务 `t1` 修改了这个数据后，事务 `t2` 也改了。则事务 `t1` 的修改结果丢失

3. 不可重复读 `non-repeated read`

   在事务 `t1` 多次读同一个数据。在该事务没有结束时，另一个事务 `t2` 也访问该数据，那么在事务 `t1` 中的两次读数据之间，由于事务 `t2` 的修改导致事务 `t1` 两次读取的数据可能不太一样

4. 幻读 `phantom read`

   与 `non-repeated read` 类似。它发生在一个事务 `t1` 读取了几行数据，紧接着另一个并发事务 `t2` 插入了一些数据时，在随后的查询中，`t1` 就会发现多了一些原本不存在的记录（好像发生了幻觉，所以称幻读）



**什么是隔离级别?**

隔离级别的出现是为了解决多个事务同时执行时可能出现的问题



需要明确的是，隔离得越严实，效率越低



`SQL` 标准的事务隔离级别包括：

- 读未提交 `read uncommited`：事务 `t1` 还没被提交时，它做的变更就可以被其他事务看到
- 读提交 `read commited`：一个事务提交之后，它做的变更才会被其他事务看到
- 可重复读 `repeated read`：一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的（未提交变更对其他事务也是不可见的）
- 串行化 `serializable`：对同一行记录，写会加 “写锁”，读会加 “读锁”。当出现冲突时，后一个事务必须等前一个事务执行完成才能继续执行



举个例子，

```mysql
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```









## 4. 深入浅出索引



## 5. 全局锁和表锁: 给表加个字段怎么有那么多阻碍?



## 6. 怎么减少行锁对性能对影响?

## 7. 事务到底是隔离的还是不隔离的?



## 8. 普通索引和唯一索引, 应该怎么选择?

## 9. MySQL 为什么有时候会选错索引?



## 10. 怎么给字符串字段加索引?



## 11. 为什么我的 MySQL 会 ”抖“ 一下?



## 12. 为什么表数据删掉一半, 表文件大小不变?





## 13. count(*) 这么慢, 怎么办?







## 14. "order by" 如何工作?











## 15. 如何正确显示随机消息?





## 16. 为什么 SQL 语句逻辑相同, 性能差异却巨大?







## 17. 为什么我只查一行的语句, 也执行那么慢?



## 18. 幻读是什么? 有什么问题?







## 19. 为什么我只查一行的语句, 锁这么多?









## 20. 有哪些提高性能的方法?







## 21. 如何保证数据不丢?





## 22. 如何保证主备一致?





## 23. 如何保证高可用?



## 24. 备库为什么会延迟好几个小时?





## 25. 主库出问题了, 从库怎么办?



## 26. 读写分离有哪些坑?





## 27. 如何判断一个数据库是不是出问题了?



## 28. 删库除了跑路, 还能怎么办?



## 29. 为什么还有 kill 不掉的语句?



## 30. 我查那么多数据, 会不会把数据库内存打爆？





## 31. 到底可不可以用 join?



## 32. join 语句怎么优化?



## 33. 为什么临时表可以重名?





## 34. 什么时候会使用内部临时表?



## 35. 还要使用 Memory 引擎吗?



## 36. 自增主键为什么不是连续的?



## 37. insert 语句的锁为什么那么多?



## 38. grant 之后要 flush privileges 吗?





## 39. 怎么最快地复制一张表?



## 40. 要不要使用分区表?

## 41. 自增 ID 用完了怎么办?



## 参考资料

- [MySQL实战45讲-极客时间](https://time.geekbang.org/column/intro/100020801)
- [MySQL 的 crash-safe 原理解析](https://juejin.im/post/6844904167782236167)
- [事务隔离级别(图文详解)](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3).md)